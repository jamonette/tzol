use chrono_tz::Tz;
use serde_json::Value;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;

fn main() {

    let json_str = include_str!("./data/CitiesAndTimeZones.json");
    let json: Value = serde_json::from_str(json_str).expect("Failed to parse json");

    let mut generated_code = "
        // This source file is generated by cargo at build time - any manual
        // changes will be overwritten.
        use std::collections::HashMap;

        pub fn get_city_to_timezone_map() -> HashMap<&'static str, &'static str> {
            let mut data: HashMap<&str, &str> = HashMap::new();
        ".to_owned();

    let mut city_to_timezone: HashMap<String, &str> = HashMap::new();
    for entry in json.as_array().unwrap() {
        if let Some(tz_str) = entry["timeZoneName"].as_str() {
            assert!(tz_str.parse::<Tz>().is_ok());
            city_to_timezone.insert(entry["city"].as_str().unwrap().to_lowercase(), tz_str);
        }
    }

    let mut insert_statements: Vec<String> = Vec::new();
    for (k, v) in city_to_timezone {
        insert_statements.push(format!("\tdata.insert(\"{}\", \"{}\");", k, v));
    }

    generated_code.push_str(&(insert_statements.join("\n")));
    generated_code.push_str( "

        data
    }
    ");

    let mut output = File::create("./src/generated_city_data.rs").unwrap();
    write!(output, "{}", generated_code).unwrap();
}
